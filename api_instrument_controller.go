/*
User Api Gateway REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pubclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// InstrumentControllerAPIService InstrumentControllerAPI service
type InstrumentControllerAPIService service

type ApiGetAllInstrumentsRequest struct {
	ctx context.Context
	ApiService *InstrumentControllerAPIService
	typeFilter *[]GetAllInstrumentsTypeFilterParameterInner
	tradingFilter *[]GetAllInstrumentsTradingFilterParameterInner
	fractionalTradingFilter *[]GetAllInstrumentsTradingFilterParameterInner
	optionTradingFilter *[]GetAllInstrumentsTradingFilterParameterInner
	optionSpreadTradingFilter *[]GetAllInstrumentsTradingFilterParameterInner
}

// optional set of security types to filter by ([GatewaySecurityType])
func (r ApiGetAllInstrumentsRequest) TypeFilter(typeFilter []GetAllInstrumentsTypeFilterParameterInner) ApiGetAllInstrumentsRequest {
	r.typeFilter = &typeFilter
	return r
}

// optional set of trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r ApiGetAllInstrumentsRequest) TradingFilter(tradingFilter []GetAllInstrumentsTradingFilterParameterInner) ApiGetAllInstrumentsRequest {
	r.tradingFilter = &tradingFilter
	return r
}

// optional set of fractional trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r ApiGetAllInstrumentsRequest) FractionalTradingFilter(fractionalTradingFilter []GetAllInstrumentsTradingFilterParameterInner) ApiGetAllInstrumentsRequest {
	r.fractionalTradingFilter = &fractionalTradingFilter
	return r
}

// optional set of option trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r ApiGetAllInstrumentsRequest) OptionTradingFilter(optionTradingFilter []GetAllInstrumentsTradingFilterParameterInner) ApiGetAllInstrumentsRequest {
	r.optionTradingFilter = &optionTradingFilter
	return r
}

// optional set of option spread trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r ApiGetAllInstrumentsRequest) OptionSpreadTradingFilter(optionSpreadTradingFilter []GetAllInstrumentsTradingFilterParameterInner) ApiGetAllInstrumentsRequest {
	r.optionSpreadTradingFilter = &optionSpreadTradingFilter
	return r
}

func (r ApiGetAllInstrumentsRequest) Execute() (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse, *http.Response, error) {
	return r.ApiService.GetAllInstrumentsExecute(r)
}

/*
GetAllInstruments Retrieves all available trading instruments with optional filtering capabilities.

Retrieves all available trading instruments with optional filtering capabilities.

This endpoint returns a comprehensive list of instruments available for trading,
with support for filtering by security type and various trading capabilities.
All filter parameters are optional and can be combined to narrow down results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllInstrumentsRequest
*/
func (a *InstrumentControllerAPIService) GetAllInstruments(ctx context.Context) ApiGetAllInstrumentsRequest {
	return ApiGetAllInstrumentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse
func (a *InstrumentControllerAPIService) GetAllInstrumentsExecute(r ApiGetAllInstrumentsRequest) (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstrumentControllerAPIService.GetAllInstruments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userapigateway/trading/instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.typeFilter != nil {
		t := *r.typeFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeFilter", t, "form", "multi")
		}
	}
	if r.tradingFilter != nil {
		t := *r.tradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tradingFilter", t, "form", "multi")
		}
	}
	if r.fractionalTradingFilter != nil {
		t := *r.fractionalTradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fractionalTradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fractionalTradingFilter", t, "form", "multi")
		}
	}
	if r.optionTradingFilter != nil {
		t := *r.optionTradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "optionTradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "optionTradingFilter", t, "form", "multi")
		}
	}
	if r.optionSpreadTradingFilter != nil {
		t := *r.optionSpreadTradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "optionSpreadTradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "optionSpreadTradingFilter", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInstrumentRequest struct {
	ctx context.Context
	ApiService *InstrumentControllerAPIService
	symbol string
	type_ GetAllInstrumentsTypeFilterParameterInner
}

func (r ApiGetInstrumentRequest) Execute() (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto, *http.Response, error) {
	return r.ApiService.GetInstrumentExecute(r)
}

/*
GetInstrument Method for GetInstrument

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbol
 @param type_
 @return ApiGetInstrumentRequest
*/
func (a *InstrumentControllerAPIService) GetInstrument(ctx context.Context, symbol string, type_ GetAllInstrumentsTypeFilterParameterInner) ApiGetInstrumentRequest {
	return ApiGetInstrumentRequest{
		ApiService: a,
		ctx: ctx,
		symbol: symbol,
		type_: type_,
	}
}

// Execute executes the request
//  @return ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto
func (a *InstrumentControllerAPIService) GetInstrumentExecute(r ApiGetInstrumentRequest) (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstrumentControllerAPIService.GetInstrument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userapigateway/trading/instruments/{symbol}/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
