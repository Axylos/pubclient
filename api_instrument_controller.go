/*
User Api Gateway REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pubclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type InstrumentControllerAPI interface {

	/*
	GetAllInstruments Retrieves all available trading instruments with optional filtering capabilities.

	Retrieves all available trading instruments with optional filtering capabilities.

This endpoint returns a comprehensive list of instruments available for trading,
with support for filtering by security type and various trading capabilities.
All filter parameters are optional and can be combined to narrow down results.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return InstrumentControllerAPIGetAllInstrumentsRequest
	*/
	GetAllInstruments(ctx context.Context) InstrumentControllerAPIGetAllInstrumentsRequest

	// GetAllInstrumentsExecute executes the request
	//  @return ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse
	GetAllInstrumentsExecute(r InstrumentControllerAPIGetAllInstrumentsRequest) (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse, *http.Response, error)

	/*
	GetInstrument Method for GetInstrument

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param symbol
	@param type_
	@return InstrumentControllerAPIGetInstrumentRequest
	*/
	GetInstrument(ctx context.Context, symbol string, type_ string) InstrumentControllerAPIGetInstrumentRequest

	// GetInstrumentExecute executes the request
	//  @return ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto
	GetInstrumentExecute(r InstrumentControllerAPIGetInstrumentRequest) (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto, *http.Response, error)
}

// InstrumentControllerAPIService InstrumentControllerAPI service
type InstrumentControllerAPIService service

type InstrumentControllerAPIGetAllInstrumentsRequest struct {
	ctx context.Context
	ApiService InstrumentControllerAPI
	typeFilter *[]string
	tradingFilter *[]string
	fractionalTradingFilter *[]string
	optionTradingFilter *[]string
	optionSpreadTradingFilter *[]string
}

// optional set of security types to filter by ([GatewaySecurityType])
func (r InstrumentControllerAPIGetAllInstrumentsRequest) TypeFilter(typeFilter []string) InstrumentControllerAPIGetAllInstrumentsRequest {
	r.typeFilter = &typeFilter
	return r
}

// optional set of trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r InstrumentControllerAPIGetAllInstrumentsRequest) TradingFilter(tradingFilter []string) InstrumentControllerAPIGetAllInstrumentsRequest {
	r.tradingFilter = &tradingFilter
	return r
}

// optional set of fractional trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r InstrumentControllerAPIGetAllInstrumentsRequest) FractionalTradingFilter(fractionalTradingFilter []string) InstrumentControllerAPIGetAllInstrumentsRequest {
	r.fractionalTradingFilter = &fractionalTradingFilter
	return r
}

// optional set of option trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r InstrumentControllerAPIGetAllInstrumentsRequest) OptionTradingFilter(optionTradingFilter []string) InstrumentControllerAPIGetAllInstrumentsRequest {
	r.optionTradingFilter = &optionTradingFilter
	return r
}

// optional set of option spread trading statuses to filter by ([ApiInstrumentDto.Trading])
func (r InstrumentControllerAPIGetAllInstrumentsRequest) OptionSpreadTradingFilter(optionSpreadTradingFilter []string) InstrumentControllerAPIGetAllInstrumentsRequest {
	r.optionSpreadTradingFilter = &optionSpreadTradingFilter
	return r
}

func (r InstrumentControllerAPIGetAllInstrumentsRequest) Execute() (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse, *http.Response, error) {
	return r.ApiService.GetAllInstrumentsExecute(r)
}

/*
GetAllInstruments Retrieves all available trading instruments with optional filtering capabilities.

Retrieves all available trading instruments with optional filtering capabilities.

This endpoint returns a comprehensive list of instruments available for trading,
with support for filtering by security type and various trading capabilities.
All filter parameters are optional and can be combined to narrow down results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return InstrumentControllerAPIGetAllInstrumentsRequest
*/
func (a *InstrumentControllerAPIService) GetAllInstruments(ctx context.Context) InstrumentControllerAPIGetAllInstrumentsRequest {
	return InstrumentControllerAPIGetAllInstrumentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse
func (a *InstrumentControllerAPIService) GetAllInstrumentsExecute(r InstrumentControllerAPIGetAllInstrumentsRequest) (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComHellopublicUserapigatewayApiRestOrderApiInstrumentResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstrumentControllerAPIService.GetAllInstruments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userapigateway/trading/instruments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.typeFilter != nil {
		t := *r.typeFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "typeFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "typeFilter", t, "form", "multi")
		}
	}
	if r.tradingFilter != nil {
		t := *r.tradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tradingFilter", t, "form", "multi")
		}
	}
	if r.fractionalTradingFilter != nil {
		t := *r.fractionalTradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fractionalTradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fractionalTradingFilter", t, "form", "multi")
		}
	}
	if r.optionTradingFilter != nil {
		t := *r.optionTradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "optionTradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "optionTradingFilter", t, "form", "multi")
		}
	}
	if r.optionSpreadTradingFilter != nil {
		t := *r.optionSpreadTradingFilter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "optionSpreadTradingFilter", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "optionSpreadTradingFilter", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type InstrumentControllerAPIGetInstrumentRequest struct {
	ctx context.Context
	ApiService InstrumentControllerAPI
	symbol string
	type_ string
}

func (r InstrumentControllerAPIGetInstrumentRequest) Execute() (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto, *http.Response, error) {
	return r.ApiService.GetInstrumentExecute(r)
}

/*
GetInstrument Method for GetInstrument

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param symbol
 @param type_
 @return InstrumentControllerAPIGetInstrumentRequest
*/
func (a *InstrumentControllerAPIService) GetInstrument(ctx context.Context, symbol string, type_ string) InstrumentControllerAPIGetInstrumentRequest {
	return InstrumentControllerAPIGetInstrumentRequest{
		ApiService: a,
		ctx: ctx,
		symbol: symbol,
		type_: type_,
	}
}

// Execute executes the request
//  @return ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto
func (a *InstrumentControllerAPIService) GetInstrumentExecute(r InstrumentControllerAPIGetInstrumentRequest) (*ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ComHellopublicUserapigatewayApiRestOrderApiInstrumentDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InstrumentControllerAPIService.GetInstrument")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userapigateway/trading/instruments/{symbol}/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"symbol"+"}", url.PathEscape(parameterValueToString(r.symbol, "symbol")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
